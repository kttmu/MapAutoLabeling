<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>Map Labeling Tool</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      display: flex;
      height: 100vh;
      color: #333;
    }

    #sidebar {
      width: 350px;
      background: #f4f4f4;
      border-right: 1px solid #ddd;
      display: flex;
      flex-direction: column;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }

    .sidebar-content {
      padding: 15px;
      overflow-y: auto;
      flex: 1;
    }

    h2,
    h3 {
      margin-top: 0;
      color: #2c3e50;
    }

    h3 {
      font-size: 1.1em;
      margin-top: 20px;
      border-bottom: 2px solid #ddd;
      padding-bottom: 5px;
    }

    .control-group {
      margin-bottom: 15px;
      background: #fff;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #ddd;
    }

    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }

    input[type="text"],
    input[type="number"],
    select {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }

    button {
      width: 100%;
      padding: 10px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      margin-bottom: 5px;
      transition: background-color 0.2s;
    }

    button:hover {
      background-color: #2980b9;
    }

    button.secondary {
      background-color: #95a5a6;
    }

    button.secondary:hover {
      background-color: #7f8c8d;
    }

    button.danger {
      background-color: #e74c3c;
    }

    button.danger:hover {
      background-color: #c0392b;
    }

    #map {
      flex: 1;
    }

    #markerList {
      margin-top: 10px;
    }

    .marker-item {
      padding: 8px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      transition: background 0.2s;
    }

    .marker-item:hover {
      background-color: #e8f6ff;
    }

    .marker-item strong {
      color: #2980b9;
    }

    #loadingOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      font-size: 1.5em;
      color: #333;
    }

    .rule-item {
      background: #eee;
      padding: 5px;
      margin-bottom: 5px;
      border-radius: 3px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9em;
    }

    .rule-item button {
      width: auto;
      padding: 2px 6px;
      margin: 0;
      font-size: 0.8em;
    }
  </style>
</head>

<body>

  <div id="sidebar">
    <div class="sidebar-content">
      <h2>Map Labeling Tool</h2>

      <div class="control-group">
        <label>Data Source</label>
        <input type="file" id="csvInput" accept=".csv">
        <button class="secondary" onclick="loadTestData()">Load Test Data (Demo)</button>
      </div>

      <div class="control-group">
        <label>Actions</label>
        <label>Model Selection</label>
        <select id="modelSelect">
          <option value="llama-3.1-8b-instant">Fast (Llama 3.1 8B)</option>
          <option value="llama-3.1-70b-versatile">Accurate (Llama 3.1 70B)</option>
        </select>
        <button onclick="autoLabel()">Auto Labeling (Groq)</button>
        <button class="secondary" onclick="exportCSV()">Export CSV</button>
      </div>

      <h3>Data Thinning</h3>
      <div class="control-group">
        <label>Min Distance (m)</label>
        <input type="number" id="thinDistance" value="0" min="0">
        <label>Sampling Rate (1/N)</label>
        <input type="number" id="thinRate" value="1" min="1">
        <button onclick="applyThinning()">Apply Thinning</button>
        <div id="thinningStatus" style="font-size: 0.85em; color: #666; margin-top: 5px; text-align: center;"></div>
      </div>

      <h3>Custom Rules</h3>
      <div class="control-group">
        <select id="ruleColumn">
          <option value="">Select Column</option>
        </select>
        <div style="display: flex; gap: 5px;">
          <select id="ruleOperator" style="flex: 1;">
            <option value=">">&gt;</option>
            <option value="<">&lt;</option>
            <option value="==">==</option>
            <option value="contains">contains</option>
          </select>
          <input type="text" id="ruleValue" placeholder="Value" style="flex: 1;">
        </div>
        <input type="text" id="ruleLabel" placeholder="Label to add">
        <button onclick="addRule()">Add Rule</button>

        <div id="ruleListContainer" style="margin-top: 10px;">
          <ul id="ruleList" style="list-style: none; padding: 0;"></ul>
        </div>
        <button onclick="applyRules()">Apply Rules</button>
        <div style="display:flex; gap:5px; margin-top:5px;">
          <button class="secondary" onclick="saveRules()">Save Rules</button>
          <button class="secondary" onclick="loadRules()">Load Rules</button>
        </div>
      </div>

      <h3>Markers</h3>
      <input type="text" id="searchInput" placeholder="Search labels...">
      <div id="markerList"></div>
    </div>
  </div>

  <div id="map"></div>

  <div id="loadingOverlay">
    <div>Processing... ⏳</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script>
    // --- Map Initialization ---
    // Enable Canvas rendering for better performance with many markers
    const map = L.map('map', { preferCanvas: true }).setView([35.6812, 139.7671], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // --- State ---
    let originalData = [];
    let markerData = [];
    let rules = [];
    let csvHeaders = [];
    let latColName = 'latitude';
    let lngColName = 'longitude';

    // --- Event Listeners ---
    document.getElementById('csvInput').addEventListener('change', function (e) {
      const file = e.target.files[0];
      if (!file) return;
      Papa.parse(file, {
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          processData(results);
        }
      });
    });

    document.getElementById('searchInput').addEventListener('input', updateMarkerList);

    // --- Data Loading ---
    function loadTestData() {
      const csv = `id,latitude,longitude,speed,rpm,altitude,time
1,35.681236,139.767125,40,2000,10,0
2,35.682236,139.768125,65,3000,12,10
3,35.683236,139.769125,55,2500,15,20
4,35.684236,139.770125,70,3500,25,30
5,35.685236,139.771125,30,1500,35,40
6,35.686236,139.772125,80,4000,36,50
7,35.687236,139.773125,45,2200,37,60
8,35.688236,139.774125,60,2800,38,70
9,35.689236,139.775125,20,1000,30,80
10,35.690236,139.776125,90,4500,20,90`;

      Papa.parse(csv, {
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
          processData(results);
        }
      });
    }

    function processData(results) {
      csvHeaders = results.meta.fields || [];
      updateColumnSelect();

      // Detect columns
      const latCol = csvHeaders.find(h => h.toLowerCase().includes('lat')) || 'latitude';
      const lngCol = csvHeaders.find(h => h.toLowerCase().includes('lon') || h.toLowerCase().includes('lng')) || 'longitude';
      const altCol = csvHeaders.find(h => h.toLowerCase().includes('alt') || h.toLowerCase().includes('ele')) || 'altitude';
      const timeCol = csvHeaders.find(h => h.toLowerCase().includes('time'));

      latColName = latCol;
      lngColName = lngCol;

      originalData = results.data.map((row, idx) => {
        const id = row.id || idx + 1;
        const lat = parseFloat(row[latCol]);
        const lng = parseFloat(row[lngCol]);
        const alt = altCol ? parseFloat(row[altCol]) : null;
        const time = timeCol ? parseFloat(row[timeCol]) : null;
        const labels = row.label ? row.label.split(';').map(l => l.trim()).filter(l => l) : [];
        return { ...row, id, lat, lng, alt, time, labels, originalRow: row };
      }).filter(d => !isNaN(d.lat) && !isNaN(d.lng));

      // Calculate Slope
      if (altCol) {
        calculateSlopes();
      }

      if (originalData.length > 0) {
        map.setView([originalData[0].lat, originalData[0].lng], 13);
      }

      applyThinning();
    }

    function calculateSlopes() {
      for (let i = 1; i < originalData.length; i++) {
        const p1 = originalData[i - 1];
        const p2 = originalData[i];

        if (p1.alt !== null && p2.alt !== null) {
          const dist = haversine(p1.lat, p1.lng, p2.lat, p2.lng);
          const altDiff = p2.alt - p1.alt;

          // Avoid division by zero or noise for very small distances
          if (dist > 5) {
            const slope = (altDiff / dist) * 100; // Percentage
            p2.slope = slope;

            // Add label if slope >= 5% (absolute value)
            if (Math.abs(slope) >= 5) {
              if (!p2.labels.includes("Slope")) {
                p2.labels.push("Slope");
              }
            }
          }
        }
      }
    }

    function updateColumnSelect() {
      const select = document.getElementById('ruleColumn');
      select.innerHTML = '<option value="">Select Column</option>';
      csvHeaders.forEach(h => {
        const opt = document.createElement('option');
        opt.value = h;
        opt.textContent = h;
        select.appendChild(opt);
      });
    }

    // --- Thinning Logic ---
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // metres
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
        Math.cos(φ1) * Math.cos(φ2) *
        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // Perpendicular distance from point p to line segment (p1, p2)
    function perpendicularDistance(p, p1, p2) {
      let x = p.lng, y = p.lat;
      let x1 = p1.lng, y1 = p1.lat;
      let x2 = p2.lng, y2 = p2.lat;

      let A = x - x1;
      let B = y - y1;
      let C = x2 - x1;
      let D = y2 - y1;

      let dot = A * C + B * D;
      let len_sq = C * C + D * D;
      let param = -1;
      if (len_sq !== 0) //in case of 0 length line
        param = dot / len_sq;

      let xx, yy;

      if (param < 0) {
        xx = x1;
        yy = y1;
      }
      else if (param > 1) {
        xx = x2;
        yy = y2;
      }
      else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      // Convert back to meters roughly for epsilon
      return haversine(y, x, yy, xx);
    }

    function douglasPeucker(points, epsilon) {
      if (points.length < 3) return points;

      let dmax = 0;
      let index = 0;
      const end = points.length - 1;

      for (let i = 1; i < end; i++) {
        const d = perpendicularDistance(points[i], points[0], points[end]);
        if (d > dmax) {
          index = i;
          dmax = d;
        }
      }

      if (dmax > epsilon) {
        const recResults1 = douglasPeucker(points.slice(0, index + 1), epsilon);
        const recResults2 = douglasPeucker(points.slice(index, end + 1), epsilon);

        return recResults1.slice(0, recResults1.length - 1).concat(recResults2);
      } else {
        return [points[0], points[end]];
      }
    }

    function applyThinning() {
      const distThresh = parseFloat(document.getElementById('thinDistance').value) || 0;
      const rate = parseInt(document.getElementById('thinRate').value) || 1;

      // Clear existing
      markerData.forEach(d => {
        if (d.marker) map.removeLayer(d.marker);
      });
      markerData = [];

      let thinned = [];

      // Strategy: Split data into chunks where labels are identical
      // This ensures we preserve label transitions (Label Persistence)
      let chunks = [];
      if (originalData.length > 0) {
        let currentChunk = [originalData[0]];
        for (let i = 1; i < originalData.length; i++) {
          const prev = originalData[i - 1];
          const curr = originalData[i];

          // Compare labels
          const prevLabels = prev.labels.slice().sort().join(';');
          const currLabels = curr.labels.slice().sort().join(';');

          if (prevLabels === currLabels) {
            currentChunk.push(curr);
          } else {
            chunks.push(currentChunk);
            currentChunk = [curr];
          }
        }
        chunks.push(currentChunk);
      }

      // Apply thinning to each chunk
      chunks.forEach(chunk => {
        let chunkResult = [];

        // 1. Simple Rate Thinning first (if requested)
        let rateThinned = chunk.filter((d, i) => (i % rate) === 0);
        // Always keep the last point of the chunk if it wasn't picked by rate
        if (chunk.length > 0 && rateThinned[rateThinned.length - 1] !== chunk[chunk.length - 1]) {
          rateThinned.push(chunk[chunk.length - 1]);
        }

        // 2. Douglas-Peucker (if distance > 0)
        if (distThresh > 0 && rateThinned.length > 2) {
          chunkResult = douglasPeucker(rateThinned, distThresh);
        } else {
          chunkResult = rateThinned;
        }

        thinned = thinned.concat(chunkResult);
      });

      // Remove duplicates that might occur at chunk boundaries
      thinned = thinned.filter((item, pos, ary) => {
        return !pos || item !== ary[pos - 1];
      });

      thinned.forEach(d => addMarker(d));

      document.getElementById('thinningStatus').innerText =
        `Showing ${thinned.length} / ${originalData.length} points`;
    }

    // --- Marker Logic ---
    function getColorByLabel(labels) {
      if (labels.includes("Slope")) return "purple";
      if (labels.includes("Urban area")) return "blue";
      if (labels.includes("Intersection")) return "orange";
      if (labels.includes("Bridge")) return "green";
      if (labels.includes("Highway") || labels.includes("Fast")) return "red";
      return "#3388ff"; // Default Leaflet blue-ish
    }

    function addMarker(data) {
      const color = getColorByLabel(data.labels);
      const marker = L.circleMarker([data.lat, data.lng], {
        radius: 8,
        color: color,
        fillColor: color,
        fillOpacity: 0.6,
        weight: 1
      }).addTo(map);

      data.marker = marker;
      marker.bindPopup(getPopupContent(data));

      marker.on('dblclick', () => {
        const streetViewURL = `https://www.google.com/maps?q=&layer=c&cbll=${data.lat},${data.lng}`;
        window.open(streetViewURL, '_blank');
      });

      markerData.push(data);
      updateMarkerList();
    }

    function getPopupContent(d) {
      let extraInfo = '';

      if (d.slope !== undefined) {
        extraInfo += `<div><strong>Calculated Slope:</strong> ${d.slope.toFixed(2)}%</div>`;
      }

      return `
      <div style="font-size:1.1em;">
        <div><strong>ID:</strong> ${d.id}</div>
        <div><strong>Lat/Lng:</strong> ${d.lat.toFixed(5)}, ${d.lng.toFixed(5)}</div>
        <div style="margin:5px 0;"><strong>Labels:</strong> ${d.labels.length ? d.labels.join(', ') : 'None'}</div>
        <hr style="margin:5px 0; border:0; border-top:1px solid #ccc;">
        ${extraInfo}
      </div>
    `;
    }

    function updateMarkerList() {
      const container = document.getElementById('markerList');
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      container.innerHTML = '';

      // Limit display to first 100 to avoid freezing UI
      let count = 0;
      for (const d of markerData) {
        if (count > 100) break;

        const labelText = d.labels.join(', ');
        const matchesSearch = labelText.toLowerCase().includes(searchTerm) ||
          String(d.id).includes(searchTerm);

        if (!searchTerm || matchesSearch) {
          const item = document.createElement('div');
          item.className = 'marker-item';
          item.innerHTML = `
          <strong>ID ${d.id}</strong> <span style="font-size:0.9em; color:#666;">[${d.labels.join(', ')}]</span><br>
          <small>${d.lat.toFixed(4)}, ${d.lng.toFixed(4)}</small>
        `;
          item.onclick = () => {
            map.setView([d.lat, d.lng], 15);
            d.marker.openPopup();
          };
          container.appendChild(item);
          count++;
        }
      }
    }

    // --- Rules Logic ---
    function addRule() {
      const col = document.getElementById('ruleColumn').value;
      const op = document.getElementById('ruleOperator').value;
      const val = document.getElementById('ruleValue').value;
      const lbl = document.getElementById('ruleLabel').value;

      if (!col || !val || !lbl) {
        alert("Please fill all rule fields");
        return;
      }

      rules.push({ col, op, val, lbl });
      renderRules();
    }

    function renderRules() {
      const list = document.getElementById('ruleList');
      list.innerHTML = '';
      rules.forEach((r, i) => {
        const li = document.createElement('li');
        li.className = 'rule-item';
        li.innerHTML = `
        <span>${r.col} ${r.op} ${r.val} &rArr; <b>${r.lbl}</b></span>
        <button class="danger" onclick="removeRule(${i})">x</button>
      `;
        list.appendChild(li);
      });
    }

    function removeRule(index) {
      rules.splice(index, 1);
      renderRules();
    }

    function applyRules() {
      markerData.forEach(d => {
        rules.forEach(r => {
          // Special handling for calculated properties not in originalRow
          let val;
          if (r.col === 'Slope (Calculated)') {
            val = d.slope || 0;
          } else {
            val = d.originalRow[r.col];
          }

          let match = false;

          const numVal = parseFloat(val);
          const numRuleVal = parseFloat(r.val);
          const isNum = !isNaN(numVal) && !isNaN(numRuleVal);

          if (r.op === '>') {
            match = isNum ? numVal > numRuleVal : val > r.val;
          } else if (r.op === '<') {
            match = isNum ? numVal < numRuleVal : val < r.val;
          } else if (r.op === '==') {
            match = isNum ? numVal === numRuleVal : val === r.val;
          } else if (r.op === 'contains') {
            match = String(val).includes(r.val);
          }

          if (match && !d.labels.includes(r.lbl)) {
            d.labels.push(r.lbl);
          }
        });

        // Update visual
        d.marker.setPopupContent(getPopupContent(d));
        const newColor = getColorByLabel(d.labels);
        d.marker.setStyle({ color: newColor, fillColor: newColor });
      });
      updateMarkerList();
    }

    // --- Rule Save/Load ---
    function saveRules() {
      const data = {
        rules: rules,
        config: {
          latCol: latColName,
          lngCol: lngColName
        }
      };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.setAttribute("href", url);
      link.setAttribute("download", "labeling_rules.json");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function loadRules() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = event => {
          try {
            const data = JSON.parse(event.target.result);
            if (data.rules) {
              rules = data.rules;
              renderRules();
              alert("Rules loaded successfully!");
            }
          } catch (err) {
            alert("Error parsing JSON: " + err.message);
          }
        };
        reader.readAsText(file);
      };
      input.click();
    }

    // --- Auto Labeling ---
    async function autoLabel() {
      if (markerData.length === 0) return;

      document.getElementById('loadingOverlay').style.display = 'flex';

      const selectedModel = document.getElementById('modelSelect').value;

      const CHUNK_SIZE = 15; // Reduced chunk size to avoid token limits
      const chunks = [];
      for (let i = 0; i < markerData.length; i += CHUNK_SIZE) {
        chunks.push(markerData.slice(i, i + CHUNK_SIZE));
      }

      try {
        for (const chunk of chunks) {
          const response = await fetch("http://localhost:5000/autolabel", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              points: chunk.map(d => ({ lat: d.lat, lng: d.lng })),
              model: selectedModel
            })
          });

          if (!response.ok) throw new Error("API Error");

          const labelsList = await response.json();

          chunk.forEach((d, i) => {
            if (labelsList[i] && labelsList[i].labels) {
              d.labels = [...new Set([...d.labels, ...labelsList[i].labels])];
              d.marker.setPopupContent(getPopupContent(d));
              const newColor = getColorByLabel(d.labels);
              d.marker.setStyle({ color: newColor, fillColor: newColor });
            }
          });
        }
      } catch (e) {
        alert("Error during auto labeling: " + e.message);
      } finally {
        updateMarkerList();
        document.getElementById('loadingOverlay').style.display = 'none';
      }
    }

    // --- Export ---
    function exportCSV() {
      const csv = Papa.unparse(markerData.map(d => {
        const row = { ...d.originalRow };
        row.label = d.labels.join(';');
        // Add slope with explicit unit in header, ensure it exists for all rows
        row['slope [%]'] = (d.slope !== undefined) ? d.slope.toFixed(2) : "";
        return row;
      }));
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.setAttribute("href", url);
      link.setAttribute("download", "labeled_points.csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  </script>

</body>

</html>